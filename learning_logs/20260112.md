# 입실 체크 해주세요 !! 🎈
# 복습 과제(09:00 ~ 09:50 / 10:00 풀이 예정)

# [과제] 판타지 RPG 무기 교체 시스템 구현

### 1. 과제 시나리오

당신은 대작 RPG 게임의 서버 개발자입니다. 플레이어는 최대 10개의 무기를 '무기 슬롯(Weapon Inventory)'에 소지할 수 있습니다.
전투 중에는 상황에 맞춰 무기를 빠르게 교체해야 하며, 각 무기는 공통적인 '공격' 동작 외에 무기 종류별 고유 특수 기술을 가지고 있습니다.

다형성(Polymorphism)을 활용하여 유연한 무기 관리 시스템을 구축하고, 특정 무기를 들었을 때만 발동되는 특수 기술 로직을 구현하세요.

### 2. 상세 가이드라인

#### [단계 1] 공통 규약 인터페이스 `Weapon` 정의

* `game.items` 패키지를 생성하세요.
* `Weapon` 인터페이스를 정의하고, 모든 무기가 반드시 가져야 할 공통 동작인 `attack()` 추상 메서드를 선언하세요.
* `void attack();`

#### [단계 2] 무기 클래스 구현 (업캐스팅 대상)

* `Weapon` 인터페이스를 구현하는 3가지 무기 클래스를 만드세요.
1. Sword (검)
* `attack()`: "검을 크게 휘두릅니다!" 출력
* 고유 메서드 `parry()`: "검으로 적의 공격을 막아냅니다!" 출력


2. Bow (활)
* `attack()`: "화살을 날립니다!" 출력
* 고유 메서드 `snipe()`: "멀리 있는 적을 저격합니다!" 출력


3. Staff (지팡이)
* `attack()`: "마법 구체를 던집니다!" 출력
* 고유 메서드 `castSpell()`: "광역 마법을 시전합니다!" 출력


#### [단계 3] 인벤토리 시스템 `Inventory` 구현

* `game.system` 패키지에 `Inventory` 클래스를 만드세요.
* 필드: `Weapon[] weaponSlots` (크기는 생성자에서 지정)
* 메서드 1: `addWeapon(Weapon weapon)`
* 배열의 비어있는 공간을 찾아 무기를 추가합니다. (업캐스팅 발생)
* 꽉 찼다면 "인벤토리가 가득 찼습니다."를 출력하세요.

* 메서드 2: `attackAll()`
* 반복문을 통해 현재 소지한 모든 무기로 한 번씩 공격(`attack()`)을 수행합니다.

#### [단계 4] 특수 기술 발동 `useSpecialAbilities()` (다운캐스팅 핵심)

* `Inventory` 클래스에 `useSpecialAbilities()` 메서드를 추가하세요.
* 배열을 순회하면서 각 무기의 실제 타입(instanceof)을 확인하세요.
* 타입에 맞게 다운캐스팅(Downcasting)을 수행한 후, 각 무기의 고유 메서드(`parry`, `snipe`, `castSpell`)를 호출하세요.

### 4. 핵심 학습 포인트 (수강생 안내용)

1. 배열의 타입: `Sword`, `Bow`는 서로 다른 클래스이지만, `Weapon`이라는 공통 인터페이스로 묶어서 `Weapon[]` 배열 하나에 담을 수 있다는 점(업캐스팅)을 이해해야 합니다.
2. 고유 기능 접근 불가: 업캐스팅된 상태(`Weapon` 타입)에서는 `weapon.parry()` 처럼 하위 클래스의 고유 메서드를 바로 호출할 수 없음을 인지해야 합니다.
3. 안전한 변환: `instanceof` 없이 무작정 `(Sword) weapon`으로 변환하면, 만약 그 무기가 `Bow`였을 경우 `ClassCastException` 오류가 발생하여 게임이 튕기게 됩니다. 이를 방지하는 방어 코드를 작성하는 것이 핵심입니다.

# 정보처리 (산업)기사 필기
2026.01.12 ~ 2026.01.15 [빈자리접수 : 2026.01.24 ~ 2026.01.25]

# 싱글톤 Singleton

## 정의
- 소프트웨어 `디자인 패턴` 중 하나로 어떤 클래스가 '하나의 인스턴스만 갖도록 보장하고,' 그 인스턴스에 접근할 수 있는 '전역적인 접근법'을 제공하는 패턴. 예를 들어, 데이터베이스 연결과 같은 리소스는 프로그램 전체에서 하나의 인스턴스만 사용해야 할 때가 많기 때문에 싱글톤 패턴을 사용함.

## 특징
1. 하나의 인스턴스만 존재 : 하나의 인스턴스만 생성되고, 이 인스턴스는 프로그램이 실행되는 동안 유지
2. 전역 접근법 : 싱글톤 인스턴스는 정적(static) 메서드를 통하여 어디서든 접근 가능 -> 객체명.메서드명(); x -> 클래스명.메서드명();
3. 인스턴스의 생명 주기 관리 : 클래스 자체가 인스턴스 생성을 관리하므로, 다른 객체들이 인스턴스를 생성하거나 폐기할 수 없음.

## 장점
1. 메모리 절약 : 불필요한 인스턴스 생성을 방지하여 메모리 절약 가능(static 변수 / 메서드의 장점과 같습니다).
2. 글로벌(전역적) 접근 : 전역적 접근이 가능하여 메모리 관리가 용이 -> 다만 잦은 접근 자체는 단점
3. 일관성 유지 : 애플리케이션 전반에서 하나의 인스턴스만 사용하기 때문에 상태 일관성을 유지

## 단점
1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용되므로 '단위 테스트'가 어려울 수 있음.
2. 의존성 숨김 : 싱글톤을 남용하면 클래스 간의 의존성을 추적하기 어려울 수 있음.